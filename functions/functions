#!/bin/bash

FUNCTIONS=${FUNCTIONS:-'/usr/share/scratchpkg'}

source "$FUNCTIONS/options"
source "$FUNCTIONS/color"
source "$FUNCTIONS/message"

### SET SOME VALUE ###
CONF_FILE="/etc/scratchpkg.conf"
BUILD_SCRIPT="spkgbuild"

ROOT_DIR="/"
INDEX_DIR="/var/lib/scratchpkg/index"

PACKAGE_DIR="/var/cache/scratchpkg/packages"
SOURCE_DIR="/var/cache/scratchpkg/sources"
WORK_DIR="/tmp"
LOG_DIR="/var/cache/scratchpkg/log"
HOOK_DIR="/etc/hooks"
PORT_DIR="/etc/ports"

OPTIONS=(!libtool emptydirs strip docs purge zipman buildflags makeflags)
PURGE_FILES=(usr/{,share/}info/dir)
DOC_DIRS=(usr/{,local/}{,share/}{doc,gtk-doc} opt/*/{doc,gtk-doc})
MAN_DIRS=({usr{,/local}{,/share},opt/*}/man)
	
if [ -f $CONF_FILE ]; then
	. $CONF_FILE
else
	msgerr "Configuration file not found."
	exit 1
fi
	
### SET BSDTAR FOR EXTRACT PROGRAM IF LIBARCHIVE IS INSTALLED ###
if [ "$(type -pa bsdtar)" ]; then
	EXTPROG=bsdtar
else
	EXTPROG=tar
fi


### FUNCTIONS LOAD BY SCRATCHPKG ###
pushd() {
    command pushd "$@" >/dev/null
}

popd() {
    command popd >/dev/null
}

rmdir_silent() {
	command rmdir "$@" 2> /dev/null
}

rm_silent() {
	command rm "$@" 2> /dev/null
}

testinput() {
	
	if [ ! "$1" ]; then
		msg "This option require an argument."
		return 1
	else
		return 0
	fi
	
}

needroot() {
	
	if [ $UID != 0 ]; then
		if [ "$#" -eq 0 ]; then
			needroot "This operation"
		else
			msgerr "$@ need root access!"
		fi
		exit 1
	fi
	
}

checktool() {
	
	if ! type -pa $1 &>/dev/null; then
		msgerr "$1 not exist in your system!"
		exit 1
	fi
	
}

getpkginfo() {
	
	description=$(cat $BUILD_SCRIPT | grep ^'# description' | sed 's/\://' | cut -d ' ' -f 3-)
	backup=$(cat $BUILD_SCRIPT | grep ^'# backup' | sed 's/\://' | cut -d ' ' -f 3-)
	conflict=$(cat $BUILD_SCRIPT | grep ^'# conflict' | sed 's/\://' | cut -d ' ' -f 3-)
	depends=$(cat $BUILD_SCRIPT | grep ^'# depends' | sed 's/\://' | cut -d ' ' -f 3-)
	makedepends=$(cat $BUILD_SCRIPT | grep ^'# makedepends' | sed 's/\://' | cut -d ' ' -f 3-)
	noextract=$(cat $BUILD_SCRIPT | grep ^'# noextract' | sed 's/\://' | cut -d ' ' -f 3-)
	options=$(cat $BUILD_SCRIPT | grep ^'# options' | sed 's/\://' | cut -d ' ' -f 3-)
	
	. $BUILD_SCRIPT
		
}

getpkginfofrompkg() {	

	name=$(tar xf $1 .pkginfo -O | grep ^name | cut -d " " -f3)
	version=$(tar xf $1 .pkginfo -O | grep ^version | cut -d " " -f3)
	release=$(tar xf $1 .pkginfo -O | grep ^release | cut -d " " -f3)
	description=$(tar xf $1 .pkginfo -O | grep ^description | cut -d " " -f3-)
	backup=$(tar xf $1 .pkginfo -O | grep ^backup | cut -d " " -f3-)
	conflict=$(tar xf $1 .pkginfo -O | grep ^conflict | cut -d " " -f3-)
	depends=$(tar xf $1 .pkginfo -O | grep ^depends | cut -d " " -f3-)
	makedepends=$(tar xf $1 .pkginfo -O | grep ^makedepends | cut -d " " -f3-)

}

getinstalledname() {
	
	iname=$(cat $INDEX_DIR/$1/.pkginfo | grep ^name | cut -d " " -f3)
	iversion=$(cat $INDEX_DIR/$1/.pkginfo | grep ^version | cut -d " " -f3)
	irelease=$(cat $INDEX_DIR/$1/.pkginfo | grep ^release | cut -d " " -f3)
	depends=$(cat $INDEX_DIR/$1/.pkginfo | grep ^depends | cut -d " " -f3-)
	backup=$(cat $INDEX_DIR/$1/.pkginfo | grep ^backup | cut -d " " -f3-)
	
	installedname=$iname-$iversion-$irelease
	
}

createtemplate() {
	
	if [ -d $1 ]; then
		msg "Error directory ${color_red}$1${color_reset} already exist"
		exit 1
	else
		mkdir $1
		echo "# description	: 
# backup	: 
# conflict	: 
# depends	: 
# makedepends	: 
# noextract	: 

name=$1
version=
release=1
options=()
source=()

build() {
	cd \$name-\$version
	./configure --prefix=/usr
	make
	make DESTDIR=\$PKG install
}" > $1/$BUILD_SCRIPT
	msg "Template port have created for ${color_green}$1${color_reset}."
	fi
	
}

checkdirexist() {
	
	for dir in "$@"; do
		if [ ! -d $dir ]; then
			msgwarn "Directory ${color_yellow}$dir${color_reset} not exist."
			DIR_ERROR=yes
		fi
	done
	
	[ "$DIR_ERROR" ] && exit 1
	
}

checkdirwrite() {
	
	for dir in "$@"; do
		if [ ! -w $dir ]; then
			msgwarn "Directory ${color_yellow}$dir${color_reset} not writable."
			DIR_ERROR=yes
		fi
	done
	
	[ "$DIR_ERROR" ] && exit 1
	
}

checkdirread() {
	
	for dir in "$@"; do
		if [ ! -x $dir ] || [ ! -r $1 ]; then
			msgwarn "Directory ${color_yellow}$dir${color_reset} not readable."
			DIR_ERROR=yes
		fi
	done
	
	[ "$DIR_ERROR" ] && exit 1
	
}
