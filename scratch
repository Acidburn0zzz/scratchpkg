#!/bin/bash

export LC_ALL=C
	
. /usr/share/scratchpkg/functions || exit 1

showinfo() {
	
	echo
	echo "      SCRATCHPKG CONFIG"
	echo "  -------------------------"
	echo
	echo "CFLAGS=$CFLAGS"
	echo "CXXFLAGS=$CXXFLAGS"
	echo "MAKEFLAGS=$MAKEFLAGS"
	echo	
	echo "CONF_FILE=$CONF_FILE"
	echo "BUILD_SCRIPT=$BUILD_SCRIPT"
	echo
	echo "ROOT_DIR=$ROOT_DIR"
	echo "INDEX_DIR=$INDEX_DIR"
	echo
	echo "PACKAGE_DIR=$PACKAGE_DIR"
	echo "SOURCE_DIR=$SOURCE_DIR"
	echo "WORK_DIR=$WORK_DIR"
	echo "LOG_DIR=$LOG_DIR"
	echo "HOOK_DIR=$HOOK_DIR"
	echo
	echo "NO_EXTRACT=$NO_EXTRACT"
	echo
	echo "OPTIONS=${OPTIONS[@]}"
	echo "PURGE_FILES=${PURGE_FILES[@]}"
	echo "DOC_DIRS=${DOC_DIRS[@]}"
	echo "MAN_DIRS=${MAN_DIRS[@]}"
	
}

listinstalled() {
	
	for pkg in $(allinstalled); do
		iname=$(installed_pkg_info name $pkg)
		iversion=$(installed_pkg_info version $pkg)
		irelease=$(installed_pkg_info release $pkg)
		echo -e "$iname ${color_green}$iversion${color_reset}-${color_blue}$irelease${color_reset}"
	done
	
}

listorphan() {
	
	# fetch all depends in all installed package
	for pkg in $(allinstalled); do
		dep=$(installed_pkg_info depends $pkg)
		for deps in ${dep[@]}; do
			ALL_DEP+=($deps)
		done
	done
	
	# find orphan package
	for all in $(ls $INDEX_DIR); do
		ORPHAN=yes
		for depended in ${ALL_DEP[@]}; do
			if [ $depended = $all ]; then
				ORPHAN=no
				break
			fi
		done
		if [ "$ORPHAN" = yes ]; then
			iname=$(installed_pkg_info name $all)
			iversion=$(installed_pkg_info version $all)
			irelease=$(installed_pkg_info release $all)
			echo -e "$iname ${color_green}$iversion${color_reset}-${color_blue}$irelease${color_reset}"
		fi
	done
	
}

searchpkg() {
	
	for port in ${PORT_REPO[@]}; do
		if [ -d $port ]; then
			pushd $port
				OUTPUT=$(grep -R "# description" | grep -i "$1" | grep "$BUILD_SCRIPT" | cut -d '/' -f1)
			popd
			if [ "$OUTPUT" ]; then
				found=yes
				for out in ${OUTPUT[@]}; do
					if [ -f $port/$out/$BUILD_SCRIPT ]; then
						pushd $port/$out
							getpkginfo
						popd
						if [ ! -z "$name" ] && [ ! -z "$version" ] && [ ! -z "$release" ]; then
							portname=$(basename $port)
							search_result="${color_blue}($portname)${color_reset} ${color_purple}$name${color_reset} ${color_cyan}$version-$release${color_reset}"
							if [ -d $INDEX_DIR/$name ]; then
								iversion=$(installed_pkg_info version $name)
								irelease=$(installed_pkg_info release $name)
								[ -f $INDEX_DIR/$name/.lock ] && ITSLOCK="[locked]"
								if [ "$version-$release" = "$iversion-$irelease" ]; then
									msg3 "$search_result ${color_green}[installed]${color_reset} ${color_blue}$ITSLOCK${color_reset}"
									msg4 "$description"
								else
									msg3 "$search_result ${color_yellow}[installed $iversion-$irelease]${color_reset} ${color_blue}$ITSLOCK${color_reset}"
									msg4 "$description"
								fi
							else
								msg3 "$search_result"
								msg4 "$description"
							fi
							unset description
						fi
					fi
				done
			fi
		fi
	done
	if [ "$found" != "yes" ]; then
		msg "No matching package found."
	fi
}

checkowner() {

	for pkg in $(allinstalled); do
		for output in $(cat $INDEX_DIR/$pkg/.files | grep $1); do
			echo -e "${color_cyan}$pkg${color_reset} => ${color_purple}$output${color_reset}"
		done
	done
	
}

showtree() {
	
	if [ ! -f $INDEX_DIR/$1/.pkginfo ]; then
		msg "Package ${color_red}$1${color_reset} not installed."
	else
		while IFS=' ' read -r line; do
			echo "$line"
		done < <(cat $INDEX_DIR/$1/.files)
	fi
	
}

checkintegrity() {
	
	pushd $ROOT_DIR
		for pkg in $(allinstalled); do
			while IFS=' ' read -r line; do
					if [ ! -e "$line" ]; then
						msg "${color_blue}$pkg${color_reset} is missing: ${color_purple}/$line${color_reset}"
						MISSING_FILE=yes
					fi
			done < <(cat $INDEX_DIR/$pkg/.files)
		done
	popd
	
	[ "$UID" != "0" ] && msg "${color_yellow}(check integrity is recommended run as root or using sudo)${color_reset}"
	[ ! "$MISSING_FILE" ] && msg "Your system file is consistent with package tree."
	
}

showpackageinfo() {
	
	if [ ! -f $1 ]; then
		msg "${color_red}$1${color_reset} not exist."
		exit 1
	else
		if [ $(tar -tf "$1" | grep -x ".pkginfo") ]; then
			getpkginfofrompkg $1
			echo -e "${color_green}info:${color_reset}"
				[ "$name" ] && echo "name = $name"
				[ "$version" ] && echo "version = $version"
				[ "$release" ] && echo "release = $release"
				[ "$description" ] && echo "description = $description"
				[ "$backup" ] && for b in ${backup[@]}; do echo "backup = $b"; done
				[ "$conflict" ] && for c in ${conflict[@]}; do echo "conflict = $c"; done
				[ "$depends" ] && for d in ${depends[@]}; do echo "depends = $d"; done
				[ "$makedepends" ] && for md in ${makedepends[@]}; do echo "makedepends = $md"; done
				echo ""
			if [ $(tar -tf "$1" | grep -x ".pkgreadme") ]; then
				echo -e "${color_green}readme:${color_reset}"
				tar -xf $1 .pkgreadme -O
				echo ""
				echo ""
			fi
			if [ $(tar -tf "$1" | grep -x ".pkginstall") ]; then
				echo -e "${color_green}pkginstall files:${color_reset}"
				tar -xf $1 .pkginstall -O
				echo ""
			fi
		else
			msg "${color_yellow}$1${color_reset} is not package created by scratchpkg."
			exit 1
		fi
	fi
		
}

showdepends() {
	
	if getportpath "$1" >/dev/null; then
		pushd $(getportpath "$1")
			getpkginfo
		popd
	else
		msgerr "Port ${color_red}$1${color_reset} not exist."
		exit 1
	fi
			
	for dep in ${depends[@]}; do
		if [ -d $INDEX_DIR/$dep ]; then
			msg2 "$dep ${color_green}[installed]${color_reset}"
		elif getportpath $dep >/dev/null; then
			msg2 "$dep"
		else
			msg2 "$dep ${color_red}[port not exist]${color_reset}"
		fi
	done
			
	for mdep in ${makedepends[@]}; do
		if [ -d $INDEX_DIR/$mdep ]; then
			msg2 "$mdep ${color_cyan}(make)${color_reset} ${color_green}[installed]${color_reset}"
		elif getportpath $mdep >/dev/null; then
			msg2 "$mdep ${color_cyan}(make)${color_reset}"
		else
			msg "$mdep ${color_cyan}(make)${color_reset} ${color_red}[port not exist]${color_reset}"
		fi
	done
}	

checkupdate() {
	
	for pkg in $(allinstalled); do
		if getportpath $pkg >/dev/null; then
			. $(getportpath $pkg)/$BUILD_SCRIPT
			iversion=$(installed_pkg_info version $pkg)
			irelease=$(installed_pkg_info release $pkg)
			[ -f "$INDEX_DIR/$pkg/.lock" ] && ITSLOCK="[locked]"
			outdatemsg="$name ${color_red}$iversion-$irelease${color_reset} => ${color_green}$version-$release${color_reset} ${color_blue}$ITSLOCK${color_reset}"
			if [ "$version" !=  "$iversion" ]; then
				vercomp $version $iversion
				if [ $? = 2 ]; then
					msg "$outdatemsg"
					OUTDATE=yes
				fi
			elif [ "$release" !=  "$irelease" ]; then
				vercomp $release $irelease
				if [ $? = 2 ]; then
					msg "$outdatemsg"
					OUTDATE=yes
				fi
			fi
			unset ITSLOCK
		fi
	done
	
	[ ! "$OUTDATE" ] && msg "All package is up to date."
}

showdependent() {
	
	if [ ! -d $INDEX_DIR/$1 ]; then
		msg "Package ${color_red}$1${color_reset} not installed."
		exit 1
	else
		for all_installed in $(ls $INDEX_DIR); do
			depend=$(cat $INDEX_DIR/$all_installed/.pkginfo | grep ^depends | cut -d " " -f3-)
				for dep in ${depend[@]}; do
					if [ $dep = $1 ]; then
						DP=yes
						msg2 "$all_installed"
					fi
				done
			makedepend=$(cat $INDEX_DIR/$all_installed/.pkginfo | grep ^makedepends | cut -d " " -f3-)
				for mdep in ${makedepend[@]}; do
					if [ $mdep = $1 ]; then
						DP=yes
						msg2 "$all_installed ${color_cyan}(make)${color_reset}"
					fi
				done
		done
	fi
	
	[ "$DP" ] || msg "No package depends on '$1'."
}

showglobaldependent() {
	
	for port in ${PORT_REPO[@]}; do
		if [ -d $port ]; then
			for all in $(ls $port/*/$BUILD_SCRIPT | rev | cut -d '/' -f2 | rev 2>/dev/null); do
				if [ -f $port/$all/$BUILD_SCRIPT ]; then
					depend=$(cat $port/$all/$BUILD_SCRIPT | grep ^'# depends' | tr -d ':' | cut -d " " -f3-)
					for dep in ${depend[@]}; do
						if [ $dep = $1 ]; then
							GDP=yes
							if [ -d $INDEX_DIR/$all ]; then
								msg2 "$all ${color_green}[installed]${color_reset}"
							else
								msg2 "$all"
							fi
						fi
					done
					makedepend=$(cat $port/$all/$BUILD_SCRIPT | grep ^'# makedepends' | tr -d ':' | cut -d " " -f3-)
					for mdep in ${makedepend[@]}; do
						if [ $mdep = $1 ]; then
							GDP=yes
							if [ -d $INDEX_DIR/$all ]; then
								msg2 "$all ${color_cyan}(make)${color_reset} ${color_green}[installed]${color_reset}"
							else
								msg2 "$all ${color_cyan}(make)${color_reset}"
							fi
						fi
					done
				fi
			done
		fi
	done
	
	[ "$GDP" ] || msg "No package depends on '$1'."
}

getportpath() {
	
	for repo in ${PORT_REPO[@]}; do
		if [[ -f $repo/$1/$BUILD_SCRIPT ]]; then
			echo "$(dirname $repo/$1/$BUILD_SCRIPT)"
			return 0
		fi
	done
	return 1
	
}

catport() {
	
	if getportpath "$1" >/dev/null; then
		cat "$(getportpath $1)/$BUILD_SCRIPT"
		exit 0
	else
		msgerr "Port '$1' not exist"
		exit 1
	fi
}

showportpath() {
	
	if getportpath "$1" >/dev/null; then
		msg "$(getportpath $1)"
		exit 0
	else
		msgerr "Port '$1' not exist"
		exit 1
	fi
	
}

getpkgcache() {
	
	for list in $(ls "$PACKAGE_DIR"); do
		[ -f "$PACKAGE_DIR"/$list ] && ALL_PACKAGES+=($list)
	done
	
	for list in $(ls "$SOURCE_DIR"); do
		[ -f "$SOURCE_DIR"/$list ] && ALL_SOURCES+=($list)
	done
	
	for repo in ${PORT_REPO[@]}; do
		for port in $(ls $repo); do
			if [ -f $repo/$port/$BUILD_SCRIPT ]; then
				. $repo/$port/$BUILD_SCRIPT
				PORT_PACKAGES+=($name-$version-$release.spkg.txz)
				if [ ! -z $source ]; then
					for src in ${source[@]}; do
						if [ $(echo $src | grep -E "(ftp|http|https)://") ]; then
							if [ $(echo $src | grep -E "::(ftp|http|https)://") ]; then
								sourcename="$(echo $src | awk -F '::' '{print $1}')"
							else
								sourcename="$(echo $src | rev | cut -d / -f 1 | rev)"
							fi
							SOURCE_NAMES+=($sourcename)
						fi
					done
				fi
			fi
		done
	done
	
	for i in ${PORT_PACKAGES[@]}; do
		for pkg in ${!ALL_PACKAGES[@]}; do
			if [ "${ALL_PACKAGES[pkg]}" = "$i" ]; then
				unset 'ALL_PACKAGES[pkg]'
				break
			fi
		done
	done
	
	for a in ${SOURCE_NAMES[@]}; do
		for src in ${!ALL_SOURCES[@]}; do
			if [ "${ALL_SOURCES[src]}" = "$a" ]; then
				unset 'ALL_SOURCES[src]'
				break
			fi
		done
	done
}

pkgcache() {
	
	getpkgcache
	
	if [ ${#ALL_PACKAGES[@]} -gt 0 ]; then
		ALL_PACKAGES_SIZE=$(pushd "$PACKAGE_DIR" && du -ch ${ALL_PACKAGES[@]} | grep total | awk '{print $1}' && popd)
	else
		ALL_PACKAGES_SIZE=0M
	fi
	
	if [ ${#ALL_SOURCES[@]} -gt 0 ]; then
		ALL_SOURCES_SIZE=$(pushd "$SOURCE_DIR" && du -ch ${ALL_SOURCES[@]} | grep total | awk '{print $1}' && popd)
	else
		ALL_SOURCES_SIZE=0M
	fi
	
	msg "${color_cyan}Package cache ($ALL_PACKAGES_SIZE):${color_reset}"
	[ ${#ALL_PACKAGES[@]} -gt 0 ] && (echo ${ALL_PACKAGES[@]} | tr ' ' '\n') || echo "(none)"
	
	echo ""
	msg "${color_cyan}Source cache ($ALL_SOURCES_SIZE):${color_reset}"
	[ ${#ALL_SOURCES[@]} -gt 0 ] && (echo ${ALL_SOURCES[@]} | tr ' ' '\n') || echo "(none)"
	
}

clearpkgcache() {
	
	needroot "Removing package & source cache"
	
	getpkgcache
	
	if [ ${#ALL_PACKAGES[@]} -gt 0 ]; then
		for pkg in ${ALL_PACKAGES[@]}; do
			rm -v $PACKAGE_DIR/$pkg
		done
	fi
	
	if [ ${#ALL_SOURCES[@]} -gt 0 ]; then
		for src in ${ALL_SOURCES[@]}; do
			rm -v $SOURCE_DIR/$src
		done
	fi
	
}

updports() {
	
	checktool httpup
	
	needroot "Updating ports"
	
	for repo in ${PORT_REPO[@]}; do
		portname=$(basename $(echo $repo))
		if [ -f /etc/ports/$portname.httpup ]; then
			. /etc/ports/$portname.httpup
			httpup sync $URL $repo
		fi
	done
	
}

duplicateports() {
	
	dup=$(find ${PORT_REPO[@]} -type d -print | egrep -xv "($(echo ${PORT_REPO[@]} | tr ' ' '|'))" | \
		rev | cut -d '/' -f1 | rev | sort | uniq -d)
	
	if [ "$dup" ]; then
		for dp in $dup; do
			for repo in ${PORT_REPO[@]}; do
				reponame=$(basename $repo)
				[ -d $repo/$dp ] && echo "$repo/$dp"
			done
		done
	else
		msg "No duplicate ports found."
	fi
	
}

listports() {
	
	for repo in ${PORT_REPO[@]}; do
		if [ "$1" = "$(basename $repo)" ]; then
			REPO_EXIST=yes
			for ports in $(ls $repo/*/$BUILD_SCRIPT | rev | cut -d '/' -f2 | rev 2>/dev/null); do
				. "$repo/$ports/$BUILD_SCRIPT"
				if [ -f "$PACKAGE_DIR/$name-$version-$release.spkg.txz" ]; then
					echo -e "$name ${color_green}$version${color_reset}-${color_blue}$release${color_reset} ${color_purple}[*]${color_reset}"
				else
					echo -e "$name ${color_green}$version${color_reset}-${color_blue}$release${color_reset}"
				fi
			done
		fi
	done
	
	[ "$REPO_EXIST" ] || msgerr "Repository ${color_red}$1${color_reset} not exist."
	
}

interrupted() {
	exit 1
}

portinstall() {
	
	for pkg in "${INSTALLPKG[@]}"; do
		if getportpath $pkg >/dev/null; then
			pushd "$(getportpath $pkg)"
				buildpkg ${OPTS[@]} || exit 1
			popd
		else
			msgerr "Port '$pkg' not found."
		fi
	done
}

listlocked() {
	
	for pkg in "$INDEX_DIR"/*/.pkginfo; do
		pkgpath=$(dirname $pkg)
		pkgname=$(basename $pkgpath)
		if [ -f "$pkgpath"/.lock ]; then
			msg "$pkgname"
		fi
	done
	
}

lockpkg() {
	
	needroot "Locking package"
	
	for pkg in "${LOCKPKG[@]}"; do
		if [ ! -d $INDEX_DIR/$pkg ]; then
			msgerr "Package '$pkg' is not installed."
		else
			touch $INDEX_DIR/$pkg/.lock && msg "Successfully locked package '$pkg'."
		fi
	done
	
}

unlockpkg() {
	
	needroot "Unlocking package"
	
	for pkg in "${UNLOCKPKG[@]}"; do
		if [ ! -d $INDEX_DIR/$pkg ]; then
			msgerr "Package '$pkg' is not installed."
		elif [ ! -f $INDEX_DIR/$pkg/.lock ]; then
			msgerr "Package '$pkg' is not locked."
		else
			rm $INDEX_DIR/$pkg/.lock && msg "Successfully unlocked package '$pkg'."
		fi
	done
	
}

missingdep() {
	
	for pkg in $(allinstalled); do
		msd=()
		msmd=()
		dep=$(installed_pkg_info depends $pkg)
		mdep=$(installed_pkg_info makedepends $pkg)
		if [ ${#dep[@]} -gt 0 ]; then
			for d in ${dep[@]}; do
				if [ ! -f "$INDEX_DIR"/$d/.pkginfo ]; then
					msd+=($d)
				fi
			done
		fi
		if [ ${#mdep[@]} -gt 0 ]; then
			for md in ${mdep[@]}; do
				if [ ! -f "$INDEX_DIR"/$md/.pkginfo ]; then
					msmd+=($md)
				fi
			done
		fi
		if [ ${#msd[@]} -gt 0 ]; then
			echo -e "${color_green}$pkg${color_reset} missing ${color_red}${msd[@]}${color_reset}"
		fi
		if [ ${#msmd[@]} -gt 0 ]; then
			echo -e "${color_green}$pkg${color_reset} missing ${color_red}${msmd[@]}${color_reset} ${color_blue}(make)${color_reset}"
		fi
	done

}

foreignpkg() {
	
	for pkg in $(allinstalled); do
		if ! getportpath $pkg >/dev/null; then
			msg $pkg
		fi
	done
	
}

missingport() {
	
	for repo in ${PORT_REPO[@]}; do
		for port in $(ls $repo/*/$BUILD_SCRIPT 2>/dev/null); do
			ms=()
			mms=()
			portname=$(echo $port | rev | cut -d '/' -f2 | rev)
			. $port
			depends=$(cat $port | grep ^'# depends' | sed 's/\://' | cut -d ' ' -f 3-)
			makedepends=$(cat $port | grep ^'# makedepends' | sed 's/\://' | cut -d ' ' -f 3-)
			if [ -n "$depends" ]; then
				for dep in $depends; do
					if ! getportpath $dep >/dev/null; then
						ms+=($dep)
						#echo -e "${color_green}$portname${color_reset} requires ${color_red}$dep${color_reset}"
					fi
				done
			fi
			if [ -n "$makedepends" ]; then
				for mdep in $makedepends; do
					if ! getportpath $mdep >/dev/null; then
						mms+=($mdep)
						#echo -e "${color_green}$portname${color_reset} requires ${color_red}$mdep${color_reset} ${color_blue}(make)${color_reset}"
					fi
				done
			fi
			if [ ${#ms[@]} -gt 0 ]; then
				echo -e "${color_green}$portname${color_reset} requires ${color_red}${ms[@]}${color_reset}"
			fi
			if [ ${#mms[@]} -gt 0 ]; then
				echo -e "${color_green}$portname${color_reset} requires ${color_red}${mms[@]}${color_reset} ${color_blue}(make)${color_reset}"
			fi
		done
	done
	
}

help() {
	
	cat << EOF
Usage:
  scratch [ <options> <arguments> ]

Options:
  -i,  --install                      install package
  -u,  --upgrade                      upgrade package
  -r,  --reinstall                    reinstall package
  -id, --ignore-dependency            skip dependency check
  -ic, --ignore-conflict              skip file/package conflict check
  -fr, --force-rebuild                rebuild package
  -sd, --source-dir <path>            override directory path for sources
  -pd, --package-dir <path>           override directory path for compiled package
  -v,  --verbose                      verbose process
  -im, --ignore-mdsum                 skip md5sum check for sources
  -um, --update-mdsum                 update md5sum file for port
  -do, --download-only                download sources only
  -eo, --extract-only                 extract sources only
  -kw, --keep-work                    keep working directory
  -rd, --redownload                   re-download sources
       --no-preinstall                skip preinstall script before build/install package
       --no-postinstall               skip postinstall script after install package
       --no-preupgrade                skip preupgrade script before upgrade package
       --no-postupgrade               skip postupgrade script after upgrade package
       --no-backup                    skip backup when upgrading package
  -p,  --package <pkgnames>           set package name to build
  -dup,--duplicate-ports              list duplicate ports
  -l,  --list-installed               show list installed packages
  -lp, --list-ports <repo>            show list ports for repository
  -lo, --list-orphan                  show list orphaned packages installed
  -ci, --check-integrity              check integrity between package's index and files in system
  -cu, --check-update                 check for package updatehes
  -up, --update-ports                 update port's repository
  -c,  --cat-port <pkgname>           print port's buildscript (spkgbuild)
  -dp, --dependent <pkgname>          show package's dependent (check through package index)
  -gdp,--global-dependent <pkgname>   show package's dependent (check through port's repository)
  -d,  --depends <pkgname>            show package's depends
  -pi, --package-info <pkg>           show package's info
  -co, --check-owner <file>           show file's owner
  -st, --show-tree <pkgname>          show list files of installed package
  -s,  --search <pattern>             search for packages in port's repository
  -t,  --create-template <portname>   create port's template for package
  -pp, --port-path                    show ports directory path
       --lock <pkgname>               lock package from upgrade
       --unlock <pkgname>             unlock package
       --listlocked                   list locked package
       --cache                        show old package and source caches
       --clear-cache                  remove all old package and source cac
       --missing-port                 list package that depends on non-exist port
       --missing-dep                  list package installed that missing it's dep in system
       --list-foreign                 list package installed but port not exist in repo
       --no-color                     disable colour for output
       --info                         show scratchpkg info (setting)
  -h,  --help                         show this help message
  
Example:
  scratch -p firefox sudo -id -kw -i     build, keep working dir, ignore missing dependency
                                         and then install firefox and sudo

  scratch -r -fr -im -p firefox sudo     rebuild, skip md5sum check for sources and then
                                         reinstall firefox and sudo
EOF
}

parse_options() {
	
	if [ -z "$1" ]; then
		help
	else
		while [ "$1" ]; do
			case $1 in
			-i  |           --install) OPTS+=($1) ;;
			-u  |           --upgrade) OPTS+=($1) ;;
			-r  |         --reinstall) OPTS+=($1) ;;
			-id | --ignore-dependency) OPTS+=($1) ;;
			-ic |   --ignore-conflict) OPTS+=($1) ;;
			          --no-preinstall) OPTS+=($1) ;;
			         --no-postinstall) OPTS+=($1) ;;
			          --no-preupgrade) OPTS+=($1) ;;
			         --no-postupgrade) OPTS+=($1) ;;
			-fr |     --force-rebuild) OPTS+=($1) ;;
			-v  |           --verbose) OPTS+=($1) ;;
			-im |      --ignore-mdsum) OPTS+=($1) ;;
			-um |      --update-mdsum) OPTS+=($1) ;;
			-do |     --download-only) OPTS+=($1) ;;
			-eo |      --extract-only) OPTS+=($1) ;;
			-kw |         --keep-work) OPTS+=($1) ;;
			-rd |        --redownload) OPTS+=($1) ;;
			              --no-backup) OPTS+=($1) ;;
			               --no-color) OPTS+=($1); NOCOLOR=yes ;;
			-dup|   --duplicate-ports) DUPLICATEPORT=yes       ;;
			-l  |    --list-installed) LISTINSTALLED=yes       ;;
			-lo |       --list-orphan) LISTORPHAN=yes          ;;
			-ci |   --check-integrity) CHECKINTEGRITY=yes      ;;
			-cu |      --check-update) CHECKUPDATE=yes         ;;
			                  --cache) PKGCACHE=yes            ;;
			            --clear-cache) CLEARPKGCACHE=yes       ;;
			            --missing-dep) MISSINGDEP=yes          ;;
			           --missing-port) MISSINGPORT=yes         ;;
			           --list-foreign) FOREIGNPKG=yes          ;;
			-up |      --update-ports) UPDATEPORTS=yes         ;;
			                   --info) SCRATCHINFO=yes         ;;
			             --listlocked) LISTLOCKED=yes          ;;
			-h  |              --help) SHOWHELP=yes            ;;
			-lp |         --list-port) testinput "$2" || exit 1 && LISTPORT="$2";       shift ;;
			-c  |          --cat-port) testinput "$2" || exit 1 && CATPORT="$2";        shift ;;
			-dp |         --dependent) testinput "$2" || exit 1 && SHOWDEPENDENT="$2";  shift ;;
			-gdp|  --global-dependent) testinput "$2" || exit 1 && GSHOWDEPENDENT="$2"; shift ;;
			-d  |           --depends) testinput "$2" || exit 1 && SHOWDEPEND="$2";     shift ;;
			-pi |      --package-info) testinput "$2" || exit 1 && SHOWPKGINFO="$2";    shift ;;
			-co |       --check-owner) testinput "$2" || exit 1 && CHECKOWNER="$2";     shift ;;
			-st |         --show-tree) testinput "$2" || exit 1 && SHOWTREE="$2";       shift ;;
			-s  |            --search) testinput "$2" || exit 1 && SEARCHPKG="$2";      shift ;;
			-t  |   --create-template) testinput "$2" || exit 1 && CREATETEMPLATE="$2"; shift ;;
			-pp |         --port-path) testinput "$2" || exit 1 && SHOWPORTPATH="$2";   shift ;;
			-sd |        --source-dir) testinput "$2" || exit 1 && OPTS+=($1 $2);       shift ;;
			-pd |       --package-dir) testinput "$2" || exit 1 && OPTS+=($1 $2);       shift ;;
			-p  |           --package) testinput "$2" || exit 1 && while [ "$2" ]; do
					                                       if echo "" $2 | grep -vq "^ -"; then
					                           	              INSTALLPKG+=($2); shift
					                                       else
						                                      break
					                                       fi
				                                         done ;;
			                   --lock) testinput "$2" || exit 1 && while [ "$2" ]; do
					                                       if echo "" $2 | grep -vq "^ -"; then
					                           	              LOCKPKG+=($2); shift
					                                       else
						                                      break
					                                       fi
				                                         done ;;
			                 --unlock) testinput "$2" || exit 1 && while [ "$2" ]; do
					                                       if echo "" $2 | grep -vq "^ -"; then
					                           	              UNLOCKPKG+=($2); shift
					                                       else
						                                      break
					                                       fi
				                                         done ;;
			                        *) msgerr "Invalid option!"; exit 1 ;;	
			esac
		shift
		done
	fi
	
}

main() {
	
	parse_options "$@"
	
	# disable colour
	if [ "$NOCOLOR" ]; then
		nocolor
	fi
	
	# show help page
	if [ "$SHOWHELP" ]; then
		help
		exit 0
	fi

	checkdirexist "$INDEX_DIR"
	
	# print duplicate ports
	if [ "$DUPLICATEPORT" ]; then
		duplicateports
		exit 0
	fi
	
	# list installed package in system
	if [ "$LISTINSTALLED" ]; then
		listinstalled
		exit 0
	fi
	
	# list orphan package (package which is no other
	# package depends on it
	if [ "$LISTORPHAN" ]; then
		listorphan
		exit 0
	fi
	
	# check integrity (check between package index and files in system)
	if [ "$CHECKINTEGRITY" ]; then
		checkintegrity
		exit 0
	fi
	
	# check package for update
	if [ "$CHECKUPDATE" ]; then
		checkupdate
		exit 0
	fi
	
	# search for old package and source cache
	if [ "$PKGCACHE" ]; then
		pkgcache
		exit 0
	fi
	
	# delete old package and sources cache
	if [ "$CLEARPKGCACHE" ]; then
		clearpkgcache
		exit 0
	fi
	
	# search for missing dependency for installed package
	if [ "$MISSINGDEP" ]; then
		missingdep
		exit 0
	fi
	
	# search for missing port (package depends on non-exist port)
	if [ "$MISSINGPORT" ]; then
		missingport
		exit 0
	fi
	
	# search for foreign port (installed package with no port in repos)
	if [ "$FOREIGNPKG" ]; then
		foreignpkg
		exit 0
	fi
	
	# update ports in repositories
	if [ "$UPDATEPORTS" ]; then
		updports
		exit 0
	fi
	
	# show scratchpkg information
	if [ "$SCRATCHINFO" ]; then
		showinfo
		exit 0
	fi
	
	# list locked package
	if [ "$LISTLOCKED" ]; then
		listlocked
		exit 0
	fi
	
	# lock package from upgrade
	if [ "${#LOCKPKG[@]}" -gt 0 ]; then
		lockpkg
		exit 0
	fi
	
	# unlock package from upgrade
	if [ "${#UNLOCKPKG[@]}" -gt 0 ]; then
		unlockpkg
		exit 0
	fi
	
	# list ports for repo (input: repo name)
	if [ "$LISTPORT" ]; then
		listports "$LISTPORT"
		exit 0
	fi
	
	# print out port's spkgbuild (input: port name)
	if [ "$CATPORT" ]; then
		catport "$CATPORT"
		exit 0
	fi
	
	# list dependents for port (check through repo. input: port name)
	if [ "$SHOWDEPENDENT" ]; then
		showdependent "$SHOWDEPENDENT"
		exit 0
	fi
	
	# list dependents for port (check through index. input: port name)
	if [ "$GSHOWDEPENDENT" ]; then
		showglobaldependent "$GSHOWDEPENDENT"
		exit 0
	fi
	
	# list depends for port (input: port name)
	if [ "$SHOWDEPEND" ]; then
		showdepends "$SHOWDEPEND"
		exit 0
	fi
	
	# show package information (input: pkgname.spkg.txz)
	if [ "$SHOWPKGINFO" ]; then
		showpackageinfo "$SHOWPKGINFO"
		exit 0
	fi
	
	# show package owner of files (input: filename)
	if [ "$CHECKOWNER" ]; then
		checkowner "$CHECKOWNER"
		exit 0
	fi
	
	# show files own by package (input: port name)
	if [ "$SHOWTREE" ]; then
		showtree "$SHOWTREE"
		exit 0
	fi
	
	# search for packages (input: pattern)
	if [ "$SEARCHPKG" ]; then
		searchpkg "$SEARCHPKG"
		exit 0
	fi
	
	# create port's template (input: port name)
	if [ "$CREATETEMPLATE" ]; then
		createtemplate "$CREATETEMPLATE"
		exit 0
	fi
	
	# create port's template (input: port name)
	if [ "$SHOWPORTPATH" ]; then
		showportpath "$SHOWPORTPATH"
		exit 0
	fi
	
	# option '-p' will go here and bring the 'OPTS=()' array
	if [ "${#INSTALLPKG[@]}" -gt 0 ]; then
		portinstall
		exit 0
	fi
	
	exit 0
}

trap "interrupted" SIGHUP SIGINT SIGQUIT SIGTERM

main "$@"
