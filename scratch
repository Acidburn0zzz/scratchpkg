#!/bin/bash

listinstalled() {
	for installed in $(ls $INDEX_DIR); do
		getinstalledname $installed
		installedpkg+=($installedname)
	done
	
	echo ${installedpkg[@]} | tr ' ' '\n'
	msg "Total installed package(s): ${#installedpkg[@]}"
}

listorphan() {
	
	for all_installed in $(ls ${INDEX_DIR}); do
		dep=$(cat $INDEX_DIR/$all_installed/.pkginfo | grep ^depends | cut -d " " -f3-)
		for deps in ${dep[@]}; do
			ALL_DEP+=($deps)
		done
	done
		
	for all in $(ls $INDEX_DIR); do
		ORPHAN=yes
		getinstalledname $all
		for depended in ${ALL_DEP[@]}; do
			if [ $depended = $all ]; then
				ORPHAN=no
				break
			fi
		done
			if [ "$ORPHAN" = yes ]; then
				ORPHAN_PKG+=($installedname)
			fi
	done
	
	echo ${ORPHAN_PKG[@]} | tr ' ' '\n'
	msg "Total orphan package(s): ${#ORPHAN_PKG[@]}"
}

searchpkg() {
	
	for port in ${PORT_REPO[@]}; do
		if [ -d $port ]; then
			OUTPUT=()
			for list in $(ls $port); do
				if [ -f $port/$list/$BUILD_SCRIPT ]; then
					if [ "$(cat $port/$list/$BUILD_SCRIPT | grep ^'# description' | tr -d ':' | cut -d ' ' -f 3- | grep -i $SEARCH_PKG)" ] || [ "$(echo $list | grep -i $SEARCH_PKG)" ]; then
						OUTPUT+=($list)
					fi
				fi
			done
			for out in ${OUTPUT[@]}; do
				if [ -f $port/$out/$BUILD_SCRIPT ]; then
					pushd $port/$out
						getpkginfo
					popd
						if [ ! -z "$name" ] && [ ! -z "$version" ] && [ ! -z "$release" ]; then
							portname=$(basename $port)
							search_result="${color_purple}($portname)${color_reset} ${color_gray}$name${color_reset} ${color_cyan}$version-$release${color_reset}"
							if [ -d $INDEX_DIR/$name ]; then
								getinstalledname $name
								if [ "$name-$version-$release" = "$installedname" ]; then
									msg3 "$search_result ${color_green}[installed]${color_reset}"
									msg4 "$description"
								else
									msg3 "$search_result"
									msg4 "$description"
								fi
							else
								msg3 "$search_result"
								msg4 "$description"
							fi
							unset description
						fi
				fi
			done
		fi
	done
}

checkowner() {

	for installed in $(ls $INDEX_DIR); do
		for output in $(cat $INDEX_DIR/$installed/.files | grep $OWNER_FILE_NAME); do
			msg "${color_cyan}$installed${color_reset} => ${color_purple}$output${color_reset}"
		done
	done
	
}

showtree() {
	
	if [ ! -d $INDEX_DIR/$TREE_PORT_NAME ]; then
		msg "Package ${color_red}$TREE_PORT_NAME${color_reset} not installed."
	else
		while IFS=' ' read -r line; do
			echo "$line"
		done < <(cat $INDEX_DIR/$TREE_PORT_NAME/.files)
	fi
	
}

checkintegrity() {
	
	pushd $ROOT_DIR
		for installed in $(ls $INDEX_DIR); do
			while IFS=' ' read -r line; do
					if [ ! -e "$line" ]; then
						msg "${color_yellow}$installed${color_reset} is missing: ${color_purple}/$line${color_reset}"
						MISSING_FILE=yes
					fi
			done < <(cat $INDEX_DIR/$installed/.files)
		done
	popd
	
	[ "$UID" != "0" ] && msg "${color_yellow}(check integrity is recommended run as root user or using sudo)${color_reset}"
	[ ! "$MISSING_FILE" ] && msg "Your system file is consistent with package tree."
	
}

showpackageinfo() {
	
	if [ ! -f $PACKAGE_INFO ]; then
		msg "${color_red}$PACKAGE_INFO${color_reset} not exist."
		exit 1
	else
		if [ $(tar -tf "$PACKAGE_INFO" | grep -x ".pkginfo") ]; then
			getpkginfofrompkg $PACKAGE_INFO
			echo -e "${color_green}info:${color_reset}"
				[ "$name" ] && echo "name = $name"
				[ "$version" ] && echo "version = $version"
				[ "$release" ] && echo "release = $release"
				[ "$description" ] && echo "description = $description"
				[ "$backup" ] && echo "backup = $backup"
				[ "$conflict" ] && echo "conflict = $conflict"
				[ "$depends" ] && echo "depends = $depends"
				[ "$makedepends" ] && echo "makedepends = $makedepends"
				echo ""
			if [ $(tar -tf "$PACKAGE_INFO" | grep -x ".pkgreadme") ]; then
				echo -e "${color_green}readme:${color_reset}"
				tar -xf $PACKAGE_INFO .pkgreadme -O
				echo ""
			fi
			if [ $(tar -tf "$PACKAGE_INFO" | grep -x ".pkginstall") ]; then
				echo -e "${color_green}pkginstall files:${color_reset}"
				tar -xf $PACKAGE_INFO .pkginstall -O
				echo ""
			fi
		else
			msg "${color_yellow}$PACKAGE_INFO${color_reset} is not package created by scratchpkg."
			exit 1
		fi
	fi
		
}

showdepends() {
	
	for portdepends in ${PORT_REPO[@]}; do
		if [ -f $portdepends/$PACKAGE_DEPENDS/$BUILD_SCRIPT ]; then
			pushd $portdepends/$PACKAGE_DEPENDS
				getpkginfo
			popd
			break
		fi
	done
	if [ -z $name ]; then
		msgerr "Port ${color_red}$PACKAGE_DEPENDS${color_reset} not exist."
		exit 1
	fi
			
	for dep in ${depends[@]}; do
		if [ -d $INDEX_DIR/$dep ]; then
			msg2 "$dep ${color_green}[installed]${color_reset}"
		else		
			PORT_EXIST=no
			for port in ${PORT_REPO[@]}; do
				if [ -f $port/$dep/$BUILD_SCRIPT ]; then
					PORT_EXIST=yes
					break
				fi
			done
				case $PORT_EXIST in
					yes)	msg2 "$dep" ;;
					no)		msg2 "$dep ${color_red}[port not exist]${color_reset}" ;;
				esac
		fi
	done
			
	for mdep in ${makedepends[@]}; do
		if [ -d $INDEX_DIR/$mdep ]; then
			msg2 "$mdep ${color_cyan}(make)${color_reset} ${color_green}[installed]${color_reset}"
		else		
			PORT_EXIST=no
			for port in ${PORT_REPO[@]}; do
				if [ -f $port/$mdep/$BUILD_SCRIPT ]; then
					PORT_EXIST=yes
					break
				fi
			done
				case $PORT_EXIST in
					yes)	msg2 "$mdep ${color_cyan}(make)${color_reset}" ;;
					no)		msg2 "$mdep ${color_cyan}(make)${color_reset} ${color_red}[port not exist]${color_reset}" ;;
				esac
		fi
	done
}

showupdate() {
	
	for package_name in $(ls $INDEX_DIR); do
		for port in ${PORT_REPO[@]}; do
			if [ -f $port/$package_name/$BUILD_SCRIPT ]; then
				. $port/$package_name/$BUILD_SCRIPT
				getinstalledname $name
					if [ "$name-$version-$release" != "$installedname" ]; then
						msg "$name ${color_red}$iversion-$irelease${color_reset} => ${color_green}$version-$release${color_reset}"
						OUTDATE=yes
					fi
				break
			fi
		done
	done
	
	[ ! "$OUTDATE" ] && msg "All package is up to date."
}

showdependent() {
	
	if [ ! -d $INDEX_DIR/$PACKAGE_DEPENDENT ]; then
		msg "Package ${color_red}$PACKAGE_DEPENDENT${color_reset} not installed."
		exit 1
	else
		for all_installed in $(ls $INDEX_DIR); do
			depend=$(cat $INDEX_DIR/$all_installed/.pkginfo | grep ^depends | cut -d " " -f3-)
				for dep in ${depend[@]}; do
					if [ $dep = $PACKAGE_DEPENDENT ]; then
							msg2 "$all_installed"
					fi
				done
			makedepend=$(cat $INDEX_DIR/$all_installed/.pkginfo | grep ^makedepends | cut -d " " -f3-)
				for mdep in ${makedepend[@]}; do
					if [ $mdep = $PACKAGE_DEPENDENT ]; then
							msg2 "$all_installed ${color_cyan}(make)${color_reset}"
					fi
				done
		done
	fi
}

showglobaldependent() {
	
	for port in ${PORT_REPO[@]}; do
		if [ -d $port ]; then
			for all in $(ls $port); do
				if [ -f $port/$all/$BUILD_SCRIPT ]; then
					depend=$(cat $port/$all/$BUILD_SCRIPT | grep ^'# depends' | tr -d ':' | cut -d " " -f3-)
						for dep in ${depend[@]}; do
							if [ $dep = $GLOBAL_PACKAGE_DEPENDENT ]; then
								if [ -d $INDEX_DIR/$all ]; then
									msg2 "$all ${color_green}[installed]${color_reset}"
								else
									msg2 "$all"
								fi
							fi
						done
					makedepend=$(cat $port/$all/$BUILD_SCRIPT | grep ^'# makedepends' | tr -d ':' | cut -d " " -f3-)
						for mdep in ${makedepend[@]}; do
							if [ $mdep = $GLOBAL_PACKAGE_DEPENDENT ]; then
								if [ -d $INDEX_DIR/$all ]; then
									msg2 "$all ${color_cyan}(make)${color_reset} ${color_green}[installed]${color_reset}"
								else
									msg2 "$all ${color_cyan}(make)${color_reset}"
								fi
							fi
						done
				fi
			done
		fi
	done	
}

catport() {
	
	for cat in ${PORT_REPO[@]}; do
		if [ -d $cat ]; then
			if [ -f $cat/$CAT_PORT/$BUILD_SCRIPT ]; then
				cat $cat/$CAT_PORT/$BUILD_SCRIPT
				break
			fi
		fi
	done
	
}

showportpath() {
	
	for path in ${PORT_REPO[@]}; do
		if [ -d $cat ]; then
			if [ -d $path/$PORT_PATH ]; then
				msg "$path/$PORT_PATH"
			fi
		fi
	done
	
}

getpkgcache() {
	
	for list in $(ls "$PACKAGE_DIR"); do
		[ -f "$PACKAGE_DIR"/$list ] && ALL_PACKAGES+=($list)
	done
	
	for list in $(ls "$SOURCE_DIR"); do
		[ -f "$SOURCE_DIR"/$list ] && ALL_SOURCES+=($list)
	done
	
	for repo in ${PORT_REPO[@]}; do
		for port in $(ls $repo); do
			if [ -d $repo/$port ]; then
				. $repo/$port/spkgbuild
				PORT_PACKAGES+=($name-$version-$release.spkg.txz)
				if [ ! -z $source ]; then
					for src in ${source[@]}; do
						if [ $(echo $src | grep -E "(ftp|http|https)://") ]; then
							if [ $(echo $src | grep -E "::(ftp|http|https)://") ]; then
								sourcename="$(echo $src | awk -F '::' '{print $1}')"
							else
								sourcename="$(echo $src | rev | cut -d / -f 1 | rev)"
							fi
							SOURCE_NAMES+=($sourcename)
						fi
					done
				fi
			fi
		done
	done
	
	for i in ${PORT_PACKAGES[@]}; do
		for pkg in ${!ALL_PACKAGES[@]}; do
			if [ "${ALL_PACKAGES[pkg]}" = "$i" ]; then
				unset 'ALL_PACKAGES[pkg]'
				break
			fi
		done
	done
	
	for a in ${SOURCE_NAMES[@]}; do
		for src in ${!ALL_SOURCES[@]}; do
			if [ "${ALL_SOURCES[src]}" = "$a" ]; then
				unset 'ALL_SOURCES[src]'
				break
			fi
		done
	done
}

pkgcache() {
	
	getpkgcache
	
	if [ ${#ALL_PACKAGES[@]} -gt 0 ]; then
		ALL_PACKAGES_SIZE=$(pushd "$PACKAGE_DIR" && du -ch ${ALL_PACKAGES[@]} | grep total | awk '{print $1}' && popd)
	else
		ALL_PACKAGES_SIZE=0M
	fi
	
	if [ ${#ALL_SOURCES[@]} -gt 0 ]; then
		ALL_SOURCES_SIZE=$(pushd "$SOURCE_DIR" && du -ch ${ALL_SOURCES[@]} | grep total | awk '{print $1}' && popd)
	else
		ALL_SOURCES_SIZE=0M
	fi
	
	msg "${color_cyan}Package cache ($ALL_PACKAGES_SIZE):${color_reset}"
	[ ${#ALL_PACKAGES[@]} -gt 0 ] && (echo ${ALL_PACKAGES[@]} | tr ' ' '\n') || echo "(none)"
	
	echo ""
	msg "${color_cyan}Source cache ($ALL_SOURCES_SIZE):${color_reset}"
	[ ${#ALL_SOURCES[@]} -gt 0 ] && (echo ${ALL_SOURCES[@]} | tr ' ' '\n') || echo "(none)"
	
}

clearpkgcache() {
	
	### CHECK FOR ROOT ACCESS ###
	if [ "$UID" != "0" ]; then
		msgerr "${color_red}Removing package & source cache need root access!${color_reset}"
		exit 1
	fi
	
	getpkgcache
	
	if [ ${#ALL_PACKAGES[@]} -gt 0 ]; then
		for pkg in ${ALL_PACKAGES[@]}; do
			rm -v $PACKAGE_DIR/$pkg
		done
	fi
	
	if [ ${#ALL_SOURCES[@]} -gt 0 ]; then
		for src in ${ALL_SOURCES[@]}; do
			rm -v $SOURCE_DIR/$src
		done
	fi
	
}

interrupted() {
	exit 1
}

pushtoport() {
	
	for port in ${PORT_REPO[@]}; do
		if [ -d $port/$PORTNAME ]; then
			PORT_EXIST=yes
			pushd $port/$PORTNAME
				INSTALL_PKG="$INSTALL_PKG" \
				UPGRADE_PKG="$UPGRADE_PKG" \
				REINSTALL_PKG="$REINSTALL_PKG" \
				IGNORE_DEP="$IGNORE_DEP" \
				IGNORE_CONFLICT="$IGNORE_CONFLICT" \
				VERBOSE_INSTALL="$VERBOSE_INSTALL" \
				FORCE_REBUILD="$FORCE_REBUILD" \
				IGNORE_MDSUM="$IGNORE_MDSUM" \
				UPDATE_MDSUM="$UPDATE_MDSUM" \
				DOWNLOAD_ONLY="$DOWNLOAD_ONLY" \
				EXTRACT_ONLY="$EXTRACT_ONLY" \
				KEEP_WORK="$KEEP_WORK" \
				REDOWNLOAD_SOURCE="$REDOWNLOAD_SOURCE" \
				SOURCE_PKG="$SOURCE_PKG" \
				OUTPUT_PKG="$OUTPUT_PKG" \
				NO_COLOR="$NO_COLOR" \
				buildpkg
			popd
			break
		fi
	done

	[ ! "$PORT_EXIST" ] && msgerr "Port ${color_red}$PORTNAME${color_reset} not found."
}

parse_options() {
	
	while [ "$1" ]; do
		case $1 in
		-i|--install)
			INSTALL_PKG=yes
			;;
		-u|--upgrade)
			UPGRADE_PKG=yes
			;;
		-r|--reinstall)
			REINSTALL_PKG=yes
			;;
		-id|--ignore-dependency)
			IGNORE_DEP=yes
			;;
		-ic|--ignore-conflict)
			IGNORE_CONFLICT=yes
			;;
		--no-preinstall)
			NO_PREINSTALL=yes
			;;
		--no-preinstall)
			NO_POSTINSTALL=yes
			;;
		-fr|--force-rebuild)
			FORCE_REBUILD=yes
			;;
		-v|--verbose)
			VERBOSE_INSTALL=yes
			;;
		-im|--ignore-mdsum)
			IGNORE_MDSUM=yes
			;;
		-um|--update-mdsum)
			UPDATE_MDSUM=yes
			;;
		-do|--download-only)
			DOWNLOAD_ONLY=yes
			;;
		-eo|--extract-only)
			EXTRACT_ONLY=yes
			;;
		-kw|--keep-work)
			KEEP_WORK=yes
			;;
		-rd|--redownload)
			REDOWNLOAD_SOURCE=yes
			;;
		--no-backup)
			NO_BACKUP=yes
			;;
		-l|--list-installed)
			LIST_INSTALLED=yes
			;;
		-lo|--list-orphan)
			LIST_ORPHAN=yes
			;;
		-ci|--check-integrity)
			CHECK_INTEGRITY=yes
			;;
		-cu|--check-update)
			CHECK_UPDATE=yes
			;;
		--no-color)
			NO_COLOR=yes
			;;
		--cache)
			PKG_CACHE=yes
			;;
		--clear-cache)
			CLEAR_PKG_CACHE=yes
			;;
		-c|--cat-port)
			if [ ! "$2" ]; then
				msg "Option '$1' require an argument (package to show its port script)"
				exit 1
			fi
				CAT_PORT="$2"
			shift
			;;
		-dp|--dependent)
			if [ ! "$2" ]; then
				msg "Option '$1' require an argument (package to show its dependent)"
				exit 1
			fi
				PACKAGE_DEPENDENT="$2"
			shift
			;;
		-gdp|--global-dependent)
			if [ ! "$2" ]; then
				msg "Option '$1' require an argument (package to show its dependent)"
				exit 1
			fi
				GLOBAL_PACKAGE_DEPENDENT="$2"
			shift
			;;
		-d|--depends)
			if [ ! "$2" ]; then
				msg "Option '$1' require an argument (package name to show its depends)"
				exit 1
			fi
				PACKAGE_DEPENDS="$2"
			shift
			;;
		-pi|--package-info)
			if [ ! "$2" ] || [ ! "$(echo $2 | grep '.spkg.txz')" ]; then
				msg "Option '$1' require an argument (package '*.spkg.txz' to show its info)."
				exit 1
			fi
				PACKAGE_INFO="$2"
			shift
			;;
		-co|--check-owner)
			if [ ! "$2" ]; then
				msg "Option '$1' require an argument (file name to show its owner)."
				exit 1
			fi
				OWNER_FILE_NAME="$2"
			shift
			;;
		-st|--show-tree)
			if [ ! "$2" ]; then
				msg "Option '$1' require an argument (package name to show tree)."
				exit 1
			fi
				TREE_PORT_NAME="$2"
			shift
			;;
		-s|--search)
			if [ ! "$2" ]; then
				msg "Option '$1' require an argument (package name to search)."
				exit 1
			fi
				SEARCH_PKG="$2"
			shift
			;;
		-p|--package)
			if [ ! "$2" ]; then
				msg "Option '$1' require an argument (package name to install/build)."
				exit 1
			fi
				PORTNAME="$2"
			shift
			;;
		-t|--create-template)
			if [ ! "$2" ]; then
				msg "Option '$1' require an argument (port name to create template)."
				exit 1
			fi
				TEMPLATE_NAME="$2"
			shift
			;;
		--path)
			if [ ! "$2" ]; then
				msg "Option '$1' require an argument (package name to show its path)"
				exit 1
			fi
				PORT_PATH="$2"
			shift
			;;
		-sd|--source-dir)
			if [ ! "$2" ]; then
				msg "Option '$1' require an argument (source path for package)."
				exit 1
			fi
			SOURCE_PKG="$2"
			shift
			;;
		-o|--output)
			if [ ! "$2" ]; then
				msg "Option '$1' require an argument (output path for compiled package)."
				exit 1
			fi
			OUTPUT_PKG="$2"
			shift
			;;
		*)
			msg "Option invalid!"
			exit 1
			;;			
		esac
		shift
	done
	
}

main() {
	
	. /usr/share/scratchpkg/functions || exit 1
	
	parse_options "$@"
	
	### DISABLE COLOR ###
	if [ "$NO_COLOR" ]; then
		nocolor
	fi
	
	### LIST PACKAGES & SOURCE CACHE ###
	if [ $PKG_CACHE ]; then
		pkgcache
		exit 0
	fi
	
	### DELETE PACKAGES & SOURCE CACHE ###
	if [ $CLEAR_PKG_CACHE ]; then
		clearpkgcache
		exit 0
	fi
	
	### SHOW PORT PATH ###
	if [ $PORT_PATH ]; then
		showportpath
		exit 0
	fi
	
	### CAT PORT ###
	if [ $CAT_PORT ]; then
		catport
		exit 0
	fi
	
	### CREATE PORT TEMPLATE ###
	if [ $TEMPLATE_NAME ]; then
		createtemplate
		exit 0
	fi
	
	### SHOW DEPENDENT (search through only installed package) ###
	if [ $PACKAGE_DEPENDENT ]; then
		showdependent
		exit 0
	fi
	
	### SHOW GLOBAL DEPENDENT (search through ports repo) ###
	if [ $GLOBAL_PACKAGE_DEPENDENT ]; then
		showglobaldependent
		exit 0
	fi
	
	### SHOW DEPENDS OF A PACKAGE ###
	if [ $PACKAGE_DEPENDS ]; then
		showdepends
		exit 0
	fi
	
	### CHECK_UPDATE ###
	if [ $CHECK_UPDATE ]; then
		showupdate
		exit 0
	fi
	
	### SHOW INFO OF A PACKAGE ###
	if [ $PACKAGE_INFO ]; then
		showpackageinfo
		exit 0
	fi
	
	### LIST INSTALLED ###
	if [ $LIST_INSTALLED ]; then
		listinstalled
		exit 0
	fi
	
	### LIST ORPHAN ###
	if [ $LIST_ORPHAN ]; then
		listorphan
		exit 0
	fi
	
	### SEARCH PACKAGE ###
	if [ $SEARCH_PKG ]; then
		searchpkg
		exit 0
	fi
	
	### CHECK PACKAGE OWNER OF A FILE ###
	if [ $OWNER_FILE_NAME ]; then
		checkowner
		exit 0
	fi
	
	### SHOW TREE OF A INSTALLED PACKAGE ###
	if [ $TREE_PORT_NAME ]; then
		showtree
		exit 0
	fi
	
	### CHECK INTEGRITY ###
	if [ $CHECK_INTEGRITY ]; then
		checkintegrity
		exit 0
	fi

	### BUILD PACKAGE ###
	if [ $PORTNAME ]; then
		pushtoport
		exit 0
	fi
	
	exit 0
}

trap "interrupted" SIGHUP SIGINT SIGQUIT SIGTERM

main "$@"
