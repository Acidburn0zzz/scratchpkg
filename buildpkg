#!/bin/bash

export LC_ALL=C

updatemdsum() {
	
	if [ ! -z $source ]; then
		for um in $(seq 0 $((${#source[@]} - 1))); do
			if [ $(echo ${source[$um]} | grep -E "(ftp|http|https)://") ]; then
				if [ $(echo ${source[$um]} | grep -E "::(ftp|http|https)://") ]; then
					sourcename="$SOURCE_DIR/$(echo ${source[$um]} | awk -F '::' '{print $1}')"
				else
					sourcename="$SOURCE_DIR/$(echo ${source[$um]} | rev | cut -d / -f 1 | rev)"
				fi
			else
				sourcename="${source[$um]}"
			fi
			needupdatechecksum="$needupdatechecksum $sourcename"
		done
		
		for file in ${needupdatechecksum[@]}; do
			if [ ! -f $file ]; then
				missingsource+=($file)
			fi
		done
		
		if [ "${#missingsource[@]}" -gt 0 ]; then
			msg "Missing source:"
			for ms in ${missingsource[@]}; do
				msg2 "$ms"
			done
			exitscript1
		fi
		
		md5sum $needupdatechecksum | awk '{ print $1 }' > .md5sum
		[ -f .md5sum ] && msg "md5sum updated."
	else
		echo "" > .md5sum
	fi
}

checkmdsum() {
	
	for i in $(cat .md5sum); do
		mdsums+=($i)
	done
	
	if [ "${#source[@]}" != "${#mdsums[@]}" ]; then
		msgerr "Total source and md5sums different."
		exitscript1
	fi
	
	for s in $(seq 0 $((${#source[@]} - 1))); do
		if [ $(echo ${source[$s]} | grep -E "(ftp|http|https)://") ]; then
			if [ $(echo ${source[$s]} | grep -E "::(ftp|http|https)://") ]; then
				sourcename=$SOURCE_DIR/$(echo ${source[$s]} | awk -F '::' '{print $1}')
			else
				sourcename=$SOURCE_DIR/$(echo ${source[$s]} | rev | cut -d / -f 1 | rev)
			fi
		else
			sourcename="${source[$s]}"
		fi
		sum=$(md5sum "$sourcename" | awk '{ print $1 }')
		if [ "$sum" != "${mdsums[$s]}" ] && [ "SKIP" != "${mdsums[$s]}" ]; then
			errormdsum+=($sourcename)
		fi
	done
	
	if [ "${#errormdsum[@]}" -gt 0 ]; then
		msgerr "md5sum mismatch:"
		for mismatch in ${errormdsum[@]}; do
			msg2 "$mismatch"
		done
		exitscript1
	fi
	
}

getsource() {
	
	for sources in ${source[@]}; do
		if [ $(echo $sources | grep -E "(ftp|http|https)://") ]; then
			downloadsource $sources
		fi
	done
}	

downloadsource(){

	if [ $(echo $1 | grep -E "::(ftp|http|https)://") ]; then
		tarballname=$(echo $1 | awk -F '::' '{print $1}')
		tarballurl=$(echo $1 | awk -F '::' '{print $2}')
	else
		tarballname=$(echo $1 | rev | cut -d / -f 1 | rev)
		tarballurl=$1
	fi
	
	WGETCMD="wget --passive-ftp --no-directories --tries=3 --waitretry=3 --output-document=$SOURCE_DIR/$tarballname.partial"
	WGETRESUME="wget -c --passive-ftp --no-directories --tries=3 --waitretry=3 --output-document=$SOURCE_DIR/$tarballname.partial"

	if [ -n $1 ]; then
		if [ "$REDOWNLOAD_SOURCE" ]; then
			if [ -f $SOURCE_DIR/$tarballname ]; then
				rm $SOURCE_DIR/$tarballname
			fi
		fi
		if [ -f $SOURCE_DIR/$tarballname ]; then
			msg "Source file ${color_green}$tarballname${color_reset} found."
		else
			checktool wget
			if [ -f $SOURCE_DIR/$tarballname.partial ]; then
				msg "Resuming ${color_green}$1${color_reset}."
				$WGETRESUME $tarballurl && mv $SOURCE_DIR/$tarballname.partial $SOURCE_DIR/$tarballname || exitscript1
			else
				msg "Downloading ${color_green}$1${color_reset}."
				$WGETCMD $tarballurl && mv $SOURCE_DIR/$tarballname.partial $SOURCE_DIR/$tarballname || exitscript1
			fi
		fi
	fi
}

preparesource() {
	
	SRC=$WORK_DIR/$name/src
	PKG=$WORK_DIR/$name/pkg
	
	[ -d "$WORK_DIR/$name" ] && rm -fr "$WORK_DIR/$name"
	
	mkdir -p $SRC $PKG
	
	if [ "${#source[@]}" -gt 0 ]; then
		msg "Preparing sources..."
		for sources in ${source[@]}; do 
			if [ $(echo $sources | grep -E "(ftp|http|https)://") ]; then
				if [ $(echo $sources | grep -E "::(ftp|http|https)://") ]; then
					tarballname=$(echo $sources | awk -F '::' '{print $1}')
				else
					tarballname=$(echo $sources | rev | cut -d / -f 1 | rev)
				fi
				NO_EXTRACT=""
					for i in ${noextract[@]}; do
						if [ "$i" = "$tarballname" ]; then
							NO_EXTRACT=yes
							msg "Preparing ${color_green}$tarballname${color_reset}..." && cp $SOURCE_DIR/$tarballname $SRC || ERROR_PREPARE_SOURCE+=($tarballname)
							break
						fi
					done
						if [ ! "$NO_EXTRACT" ]; then
							case $tarballname in
								*.tar|*.tar.gz|*.tar.Z|*.tgz|*.tar.bz2|*.tbz2|*.tar.xz|*.txz|*.tar.lzma|*.zip|*.rpm)
									COMMAND="$EXTPROG -p -o -C $SRC -xf $SOURCE_DIR/$tarballname"
									MODE="Unpacking" ;;
								*)
									COMMAND="cp $SOURCE_DIR/$tarballname $SRC"
									MODE="Preparing" ;;				
							esac
							
							msg2 "$MODE ${color_green}$tarballname${color_reset}..."
							$COMMAND
							
							if [ $? != 0 ]; then
								msgerr "$MODE ${color_red}$tarballname${color_reset} failed."
								clearworkdir
								exitscript1
							fi						
						fi
			else
				msg2 "Preparing ${color_green}$sources${color_reset}..." && cp $sources $SRC || ERROR_PREPARE_SOURCE+=($sources)
			fi
		done
	fi
	
	if [ "${#ERROR_PREPARE_SOURCE[@]}" -gt 0 ]; then
		msgerr "Failed prepared source:"
		for err in ${ERROR_PREPARE_SOURCE[@]}; do
			msg2 $err
		done
		clearworkdir
		exitscript1
	fi
}

loadspkgbuild() {

	if [ -f $BUILD_SCRIPT ]; then
		getpkginfo
	else
		msgerr "No $BUILD_SCRIPT found."
		exitscript1
	fi

}

buildpackage() {
	
	msg "Start build ${color_green}$name-$version-$release${color_reset}."
	
	pushd $SRC
	
	(set -e -x ; build)
		
		if [ $? != 0 ]; then
			msgerr "Build ${color_red}$PKGNAME${color_reset} failed."	
			clearworkdir
			exitscript1
		else
			msg "Successfully build ${color_green}$name-$version-$release${color_reset}."
		fi
	
	popd
}

runpreinstall() {
	
	if [ "`type -t pre_install`" = "function" ]; then
		pre_install "$version" && PREINSTALL_STATUS=OK || PREINSTALL_STATUS=KO
	fi
}

packaging() {
	
	[ -f $name.install ] && cp $name.install $PKG/.pkginstall
	[ -f readme ] && cp readme $PKG/.pkgreadme
	
	pushd $PKG
	
	if check_options purge y; then
		purgefiles
	fi
	
	if check_options !emptydirs y; then
		removeemptydirs
	fi
	
	if check_options !docs y && [[ -n ${DOC_DIRS[*]} ]]; then
		removedocs
	fi
	
	if check_options !libtool y; then
		removelibtool
	fi
	
	if check_options strip y; then
		strip_files
	fi
	
	if check_options zipman y && [[ -n ${MAN_DIRS[*]} ]]; then
		compressinfomanpages
	fi
	
	echo "# Generated by buildpkg" > .pkginfo
	echo "# `date`" >> .pkginfo
	echo "name = $name" >> .pkginfo
	echo "version = $version" >> .pkginfo
	echo "release = $release" >> .pkginfo
	[ -n "$description" ] && echo "description = $description" >> .pkginfo
	[ -n "$backup" ] && for b in ${backup[@]}; do echo "backup = $b" >> .pkginfo; done
	[ -n "$conflict" ] && for c in ${conflict[@]}; do echo "conflict = $c" >> .pkginfo; done
	[ -n "$depends" ] && for d in ${depends[@]}; do echo "depends = $d" >> .pkginfo; done
	[ -n "$makedepends" ] && for md in ${makedepends[@]}; do echo "makedepends = $md" >> .pkginfo; done
	[ -n "$noextract" ] && echo "noextract = $noextract" >> .pkginfo
	
	msg "Packaging ${color_green}$name-$version-$release${color_reset}..."
	
	for file in .pkginstall .pkgreadme; do
		if [ -f $file ]; then
			addtotar+=($file)
		fi
	done
	tar -c -J -p -f $PACKAGE_DIR/$PKGNAME * .pkginfo "${addtotar[@]}"
	
	if [ $? != 0 ]; then
		msgerr "Packaging ${color_red}$PKGNAME${color_reset} failed."
		if [ -f $PACKAGE_DIR/$PKGNAME ]; then
			rm $PACKAGE_DIR/$PKGNAME
		fi
		exitscript1
	else
		pkgsize="$(ls -lh $PACKAGE_DIR/$PKGNAME | awk '{print $5}')"
		$EXTPROG -t -v -f $PACKAGE_DIR/$PKGNAME
		msg "Successfully create package ${color_green}$PKGNAME${color_reset}. (${pkgsize})"
	fi
	
	case $PREINSTALL_STATUS in
		OK) msg "preinstall	: ${color_green}OK${color_reset}" ;;
		KO) msg "preinstall	: ${color_red}FAIL${color_reset}" ;;
	esac
	
	popd
	
}

buildpkg() {
	
	getsource
	
	if [ ! "$IGNORE_MDSUM" ]; then
		if [ -f .md5sum ]; then
			checkmdsum
		else
			updatemdsum
		fi
	fi
	preparesource
	
	[ "$UPGRADE_PKG" ] && NO_PREINSTALL=yes
	
	if [ ! "$NO_PREINSTALL" ]; then
		runpreinstall
		NO_PREINSTALL=yes
	fi
	
	if check_options makeflags n; then
		unset "MAKEFLAGS"
	elif check_options makeflags y; then
		export MAKEFLAGS
	fi
	
	if check_options buildflags n; then
		unset CFLAGS CXXFLAGS
	elif check_options buildflags y; then
		export CFLAGS CXXFLAGS
	fi
	
	buildpackage
	
	if [ "$FORCE_REBUILD" ]; then
		if [ -f $PACKAGE_DIR/$PKGNAME ]; then
			rm $PACKAGE_DIR/$PKGNAME
		fi
	fi
	
	packaging
	clearworkdir
		
}

checkdeps() {
	
	for dep in ${depends[@]}; do
		if [ ! -d $INDEX_DIR/$dep ]; then
			MSDEP+=($dep)
		fi
	done
	
	for makedep in ${makedepends[@]}; do
		if [ ! -d $INDEX_DIR/$makedep ]; then
			MSMKDEP+=($makedep)
		fi
	done
	
	if [ "${#MSDEP[@]}" -gt 0 ] || [ "${#MSMKDEP[@]}" -gt 0 ]; then
		msg "Missing dependencies:"
		for msd in ${MSDEP[@]}; do
			msg2 "$msd"
		done
		for msmkd in ${MSMKDEP[@]}; do
			msg2 "$msmkd ${color_cyan}(make)${color_reset}"
		done
		exitscript1
	fi
	
}

check_directory() {
	
	for dir in $WORK_DIR $SOURCE_DIR $PACKAGE_DIR; do
		if [ ! -d $dir ]; then
			msgwarn "Directory ${color_yellow}$dir${color_reset} not exist."
			DIR_ERROR=yes
		elif [ ! -w $dir ]; then
			msgwarn "Directory ${color_yellow}$dir${color_reset} not writable."
			DIR_ERROR=yes
		elif [ ! -x $dir ] || [ ! -r $1 ]; then
			msgwarn "Directory ${color_yellow}$dir${color_reset} not readable."
			DIR_ERROR=yes
		fi
	done
	
	[ "$DIR_ERROR" ] && exitscript1
}

# remove lock file and exit 1
exitscript1() {
	
	if [ -f /tmp/spkg.$name.lock ]; then
		rm /tmp/spkg.$name.lock
	fi
	exit 1
}

# remove lock file and exit 0
exitscript0() {
	
	if [ -f /tmp/spkg.$name.lock ]; then
		rm /tmp/spkg.$name.lock
	fi
	exit 0
}

# create lock file in /tmp prevent for build same package simultaneously 
lockbuild() {
	
	if [ ! -f /tmp/spkg.$name.lock ]; then
		touch /tmp/spkg.$name.lock
	fi
}

updatepkgdepends() {
	
	# only installed depends will count as depends
	for dep in ${depends[@]}; do
		if [ -d $INDEX_DIR/$dep ]; then
			newdep+=($dep)
		fi
	done
	depends="${newdep[@]}"
	
	# only installed makedepends will count as makedepends
	for mdep in ${makedepends[@]}; do
		if [ -d $INDEX_DIR/$mdep ]; then
			newmdep+=($mdep)
		fi
	done
	makedepends="${newmdep[@]}"
	
}

checkneworphan() {
	
	for md in ${makedepends[@]}; do
		removemakedepends $md
	done
	if [ "${#saferemove[@]}" -gt 0 ]; then
		msg "Package safe for remove:"
		for saferem in ${saferemove[@]}; do
			msg2 "$saferem"
		done
	fi
	
}

removemakedepends() {
	
	ORPHAN="yes"
	for all_installed in $(ls $INDEX_DIR); do
		depend=$(cat $INDEX_DIR/$all_installed/.pkginfo | grep ^depends | cut -d " " -f3-)
			for dep in ${depend[@]}; do
				if [ $dep = $1 ]; then
					ORPHAN="no"
				fi
			done
	done
	
	[ "$ORPHAN" = "yes" ] && [ -d $INDEX_DIR/$1 ] && saferemove+=($1)
}

clearworkdir() {
	
	if [ ! "$KEEP_WORK" ]; then
		if [ ! -z $name ]; then
			if [ -d $WORK_DIR/$name ]; then
				rm -fr $WORK_DIR/$name
			fi
		fi
	fi
	
}

interrupted() {
	echo ""
	msg "${color_yellow}Interrupted!${color_reset}"
	clearworkdir
	exitscript1
}

help() {
	
	echo -e "Usage:"
	echo -e "\t`basename $0` < options >"
	echo -e ""
	echo -e "Example:"
	echo -e "\t`basename $0` -fr -kw -i	this will force rebuild, install package and keep working directory"
	echo -e ""
	echo -e "Options:"
	echo -e "\t-i,\t--install		install package into system"
	echo -e "\t-u,\t--upgrade		upgrade package"
	echo -e "\t-r,\t--reinstall		reinstall package"
	echo -e "\t-id,\t--ignore-dependency	ignore dependency"
	echo -e "\t-ic,\t--ignore-conflict	ignore conflict when installing package"
	echo -e "\t-v,\t--verbose		verbose install process"
	echo -e "\t\t--no-preinstall		skip preinstall script when build/install package"
	echo -e "\t\t--no-postinstall	skip postinstall script after install package"
	echo -e "\t\t--no-color		disable color"
	echo -e "\t-fr,\t--force-rebuild		rebuild package"
	echo -e "\t-im,\t--ignore-mdsum		skip md5sum checking"
	echo -e "\t-um,\t--update-mdsum		update md5sum"
	echo -e "\t-cm,\t--check-mdsum		check md5sum for source file"
	echo -e "\t-do,\t--download-only		download only source file"
	echo -e "\t-eo,\t--extract-only		extract only source file"
	echo -e "\t-kw,\t--keep-work		keep working directory"
	echo -e "\t-ns,\t--no-strip		skip strip package library and binary"
	echo -e "\t-rd,\t--redownload		re-download source file"
	echo -e "\t-sd,\t--source-dir <path>	override source dir"
	echo -e "\t-o,\t--output <path>		override output path for packages"
	echo -e "\t-h,\t--help			show this help page"
	echo -e ""
	echo -e "Note:"
	echo -e "\t* use `basename $0` without any options will only download source and build package by using other default options"
	echo -e "\t* buildpkg need run inside port directory"
	
}

parse_options() {
	
	while [ "$1" ]; do
		case $1 in
		# this option will pass to installpkg
		-i|--install)
			INSTALL_PKG=yes
			;;
		-u|--upgrade)
			UPGRADE_PKG=yes
			;;
		-r|--reinstall)
			REINSTALL_PKG=yes
			;;
		-id|--ignore-dependency)
			IGNORE_DEP=yes
			;;
		-ic|--ignore-conflict)
			IGNORE_CONFLICT=yes
			;;
		--no-preinstall)
			NO_PREINSTALL=yes
			;;
		--no-preinstall)
			NO_POSTINSTALL=yes
			;;
		-v|--verbose)
			VERBOSE_INSTALL=yes
			;;
		--no-color)
			NO_COLOR=yes
			;;
		--no-orphan-check)
			NO_ORPHAN_CHECK=yes
			;;
		-fr|--force-rebuild)
			FORCE_REBUILD=yes
			;;
		-im|--ignore-mdsum)
			IGNORE_MDSUM=yes
			;;
		-um|--update-mdsum)
			UPDATE_MDSUM=yes
			;;
		-do|--download-only)
			DOWNLOAD_ONLY=yes
			;;
		-eo|--extract-only)
			EXTRACT_ONLY=yes
			;;
		-kw|--keep-work)
			KEEP_WORK=yes
			;;
		-rd|--redownload)
			REDOWNLOAD_SOURCE=yes
			;;
		--no-backup)
			NO_BACKUP=yes
			;;
		-h|--help)
			SHOW_HELP=yes
			;;
		-sd|--source-dir)
			if [ ! "$2" ]; then
				msg "Option '$1' require an argument (source path for package)."
				exit 1
			fi
			SOURCE_PKG="$2"
			shift
			;;
		-o|--output)
			if [ ! "$2" ]; then
				msg "Option '$1' require an argument (output path for compiled package)."
				exit 1
			fi
			OUTPUT_PKG="$2"
			shift
			;;
		*)
			msg "Option invalid!"
			exit 1
			;;
		esac
		shift
	done
	
}

main() {
	
	. /usr/share/scratchpkg/functions || exit 1
	
	parse_options "$@"
	
	### DISABLE COLOR ###
	if [ "$NO_COLOR" ]; then
		nocolor
	fi
	
	### SHOW HELP ###
	if [ "$SHOW_HELP" ]; then
		help
		exit 0
	fi
	
	### SET OUTPUT PATH FOR PACKAGE ###
	if [ $OUTPUT_PKG ]; then
		PACKAGE_DIR="$OUTPUT_PKG"
	fi
	
	### SET SOURCE PATH ###
	if [ $SOURCE_PKG ]; then
		SOURCE_DIR="$SOURCE_PKG"
	fi
	
	check_directory
	
	loadspkgbuild
	
	if [ "$INSTALL_PKG" ] || [ "$UPGRADE_PKG" ] || [ "$REINSTALL_PKG" ]; then
		NO_ORPHAN_CHECK=yes
	fi
	
	### CHECK SPKGBUILD ###
	if [ -z "$name" ] || [ -z "$version" ] || [ -z "$release" ] || [ "$(basename `pwd`)" != "$name" ] || [ "`type -t build`" != "function" ]; then
		msgerr "Please check spkgbuild."
		exit 1
	fi
	
	PKGNAME="$name-$version-$release.spkg.txz"
	
	### UPDATE CHECKSUM ###
	if [ "$UPDATE_MDSUM" ]; then
		getsource
		updatemdsum
		exit 0
	fi
	
	### CHECK FOR LOCK FILE ###
	if [ -f /tmp/spkg.$name.lock ]; then
		msgerr "Cant build same package simultaneously."
		msgerr "remove ${color_yellow}/tmp/spkg.$name.lock${color_reset} if no build process for ${color_yellow}$name.${color_reset}"
		exit 1
	fi
	
	### DOWNLOAD ONLY ###
	if [ "$DOWNLOAD_ONLY" ]; then
		getsource
		exit 0
	fi
	
	### EXTRACT ONLY ###
	if [ "$EXTRACT_ONLY" ]; then
		getsource
		preparesource
		exit 0
	fi
	
	### CREATE LOCK FILE ###
	lockbuild
	
	### BUILD ###
	if [ -f $PACKAGE_DIR/$PKGNAME ] && [ ! "$FORCE_REBUILD" ]; then # if package txz exist and not force rebuild
		if [ ! "$INSTALL_PKG" ] && [ ! "$REINSTALL_PKG" ] && [ ! "$UPGRADE_PKG" ]; then
			msg "${color_green}$PKGNAME${color_reset} is up-to-date."
			exitscript0
		fi
	else
		# dependency check
		if [ ! "$IGNORE_DEP" ]; then
			checkdeps
		else	
			updatepkgdepends
		fi
		[ -f $name.install ] && . $name.install
		buildpkg
		IGNORE_DEP=yes
		if [ ! "$NO_ORPHAN_CHECK" ]; then
			checkneworphan
		fi
	fi
	
	### INSTALL PACKAGE ###
	if [ "$INSTALL_PKG" ] || [ "$REINSTALL_PKG" ] || [ "$UPGRADE_PKG" ]; then
		IGNORE_CONFLICT="$IGNORE_CONFLICT" \
		IGNORE_DEP="$IGNORE_DEP" \
		REINSTALL_PKG="$REINSTALL_PKG" \
		UPGRADE_PKG="$UPGRADE_PKG" \
		VERBOSE_INSTALL="$VERBOSE_INSTALL" \
		NO_PREINSTALL="$NO_PREINSTALL" \
		NO_POSTINSTALL="$NO_POSTINSTALL" \
		NO_COLOR="$NO_COLOR" \
		NO_BACKUP="$NO_BACKUP" \
		NO_ORPHAN_CHECK="$NO_ORPHAN_CHECK" \
		installpkg $PACKAGE_DIR/$PKGNAME || exitscript1
		exitscript0
	fi
	
	exitscript0
	
}

trap "interrupted" SIGHUP SIGINT SIGQUIT SIGTERM

main "$@"
