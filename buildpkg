#!/bin/bash

updatemdsum() {
	
	if [ ! -z $source ]; then
		for sources in ${source[@]}; do
			if [[ $sources =~ ^(http|https|ftp)://.*/(.+) ]]; then
				sourcename=$SOURCE_DIR/$(echo $sources | rev | cut -d / -f 1 | rev)
			else
				sourcename="$sources"
			fi
			needupdatechecksum="$needupdatechecksum $sourcename"
		done
		
		for file in ${needupdatechecksum[@]}; do
			if [ ! -f $file ]; then
				msg "Error updating checksum, source not found."
				exitscript1
			fi
		done
		
		md5sum $needupdatechecksum | awk '{ print $1 }' > .md5sum
		[ -f .md5sum ] && msg "md5sum updated."
	else
		touch .md5sum
	fi
}

checkmdsum() {
	
	for sources in ${source[@]}; do
		if [[ $sources =~ ^(http|https|ftp)://.*/(.+) ]]; then
			sourcename=$SOURCE_DIR/$(echo $sources | rev | cut -d / -f 1 | rev)
		else
			sourcename="$sources"
		fi
		sourcemd5sum=$(md5sum $sourcename | awk '{ print $1 }')
		if [ ! $(grep $sourcemd5sum .md5sum) ]; then
			msg "${color_red}Checksum error:${color_reset} $sourcename"
			CHECKSUM_ERROR=yes
		fi
	done
	
	[ "$CHECKSUM_ERROR" ] && exitscript1
	
}

getsource() {
	
	for sources in ${source[@]}; do 
		if [[ $sources =~ ^(http|https|ftp)://.*/(.+) ]]; then
			downloadsource $sources
		fi
	done
}

downloadsource(){

	tarballname=$(echo $1 | rev | cut -d / -f 1 | rev)
	WGETCMD="wget --passive-ftp --no-directories --tries=3 --waitretry=3 --output-document=$SOURCE_DIR/$tarballname.partial"
	WGETRESUME="wget -c --passive-ftp --no-directories --tries=3 --waitretry=3 --output-document=$SOURCE_DIR/$tarballname.partial"

	if [ -n $1 ]; then
		if [ "$REDOWNLOAD_SOURCE" ]; then
			if [ -f $SOURCE_DIR/$tarballname ]; then
				rm $SOURCE_DIR/$tarballname
			fi
		fi
		if [ -f $SOURCE_DIR/$tarballname ]; then
			msg "Source file ${color_green}$tarballname${color_reset} found."
		else
			if [ -f $SOURCE_DIR/$tarballname.partial ]; then
				msg "Resuming ${color_green}$1${color_reset}."
				$WGETRESUME $1 && mv $SOURCE_DIR/$tarballname.partial $SOURCE_DIR/$tarballname || exitscript1
			else
				msg "Downloading ${color_green}$1${color_reset}."
				$WGETCMD $1 && mv $SOURCE_DIR/$tarballname.partial $SOURCE_DIR/$tarballname || exitscript1
			fi
		fi
	fi
}

preparesource() {
	
	SRC=$WORK_DIR/$name/src
	PKG=$WORK_DIR/$name/pkg
	
	if [ -d $WORK_DIR/$name ]; then
		rm -fr $WORK_DIR/$name
	fi
	
	mkdir -p $SRC $PKG
	
	for sources in ${source[@]}; do 
		if [[ $sources =~ ^(http|https|ftp)://.*/(.+) ]]; then
			tarballname=$(echo $sources | rev | cut -d / -f 1 | rev)
				case $tarballname in
					*.tar|*.tar.gz|*.tar.Z|*.tgz|*.tar.bz2|*.tbz2|*.tar.xz|*.txz|*.tar.lzma|*.zip|*.rpm)
						COMMAND="$EXTPROG -p -o -C $SRC -xf $SOURCE_DIR/$tarballname"
						MODE="Unpacking" ;;
					*)
						COMMAND="cp $SOURCE_DIR/$tarballname $SRC"
						MODE="Preparing" ;;				
				esac
						
				$COMMAND
				
				if [ $? != 0 ]; then
					msg "$MODE ${color_red}$tarballname${color_reset} failed."
					clearworkdir
					exitscript1
				else
					msg "$MODE ${color_green}$tarballname${color_reset} success."
				fi
		else
			cp $sources $SRC || ERROR_PREPARE_SOURCE=yes
		fi
	done
	
	if [ "$ERROR_PREPARE_SOURCE" ]; then
		msg "Error preparing ${color_red}$sources${color_reset}."
		clearworkdir
		exitscript1
	fi
	
	for runscript in preinstall postinstall preremove postremove readme; do
		if [ -f $runscript ]; then
			[ ! -d $PKG/.pkginstall ] && mkdir $PKG/.pkginstall
			cp $runscript $PKG/.pkginstall
		fi
	done
}

loadspkgbuild() {

	if [ -f $BUILD_SCRIPT ]; then
		. $BUILD_SCRIPT
		getpkginfo
	else
		msg "${color_red}Error no $BUILD_SCRIPT found.${color_reset}"
		exitscript1
	fi

}

buildpackage() {
	
	msg "Start build ${color_green}$name-$version-$release${color_reset}."
	
	pushd $SRC
	
	(set -e -x ; build)
		
		if [ $? != 0 ]; then
			msg "Build ${color_red}$PKGNAME${color_reset} failed."	
			clearworkdir
			exitscript1
		else
			msg "Successfully build ${color_green}$name-$version-$release${color_reset}."
		fi
	
	popd
}

runpreinstall() {
	
	if [ -f preinstall ]; then
		msg "Running preinstall script..."
		sh preinstall && PREINSTALL_STATUS=OK || PREINSTALL_STATUS=KO
	fi
}

packaging() {
	
	pushd $PKG
	
	if [ -f usr/share/info/dir ]; then
		rm usr/share/info/dir
	fi
	
	if [ ! "$NO_STRIP" ]; then
		strip_files
	fi
	
	compressinfomanpages
	purgefiles
	
	for dep in ${depends[@]}; do
		if [ -d $INDEX_DIR/$dep ]; then
			if [ -z "$newdep" ]; then
				newdep="$dep"
			else
				newdep="$newdep $dep"
			fi
		fi
	done
	
	for mdep in ${makedepends[@]}; do
		if [ -d $INDEX_DIR/$mdep ]; then
			if [ -z "$newmdep" ]; then
				newmdep="$mdep"
			else
				newmdep="$newmdep $mdep"
			fi
		fi
	done
	
	echo "# Generated by buildpkg" > .pkginfo
	echo "# `date`" >> .pkginfo
	echo "name = $name" >> .pkginfo
	echo "version = $version" >> .pkginfo
	echo "release = $release" >> .pkginfo
	[ -n "$description" ] && echo "description = $description" >> .pkginfo
	[ -n "$homepage" ] && echo "homepage = $homepage" >> .pkginfo
	[ -n "$maintainer" ] && echo "maintainer = $maintainer" >> .pkginfo
	[ -n "$backup" ] && echo "backup = ${backup[@]}" >> .pkginfo
	[ -n "$conflict" ] && echo "conflict = ${conflict[@]}" >> .pkginfo
	[ -n "$newdep" ] && echo "depends = ${newdep[@]}" >> .pkginfo
	[ -n "$newmdep" ] && echo "makedepends = ${newmdep[@]}" >> .pkginfo
	
	msg "Packaging ${color_green}$name-$version-$release${color_reset}..."
	if [ -d .pkginstall ]; then
		tar -c -J -f $PACKAGE_DIR/$PKGNAME * .pkginfo .pkginstall
	else
		tar -c -J -f $PACKAGE_DIR/$PKGNAME * .pkginfo
	fi
	
	if [ $? != 0 ]; then
		msg "Packaging ${color_red}$PKGNAME${color_reset} failed."
		if [ -f $PACKAGE_DIR/$PKGNAME ]; then
			rm $PACKAGE_DIR/$PKGNAME
		fi
		exitscript1
	else	
		$EXTPROG -t -v -f $PACKAGE_DIR/$PKGNAME
		msg "Successfully create package ${color_green}$PKGNAME${color_reset}."
	fi
	
	case $PREINSTALL_STATUS in
		OK) msg "preinstall	: ${color_green}OK${color_reset}" ;;
		KO) msg "preinstall	: ${color_red}FAIL${color_reset}" ;;
	esac
	
	popd
	
}

purgefiles() {
	
	if [ -f /etc/scratchpkg.conf.d/$PURGE_FILE ]; then
		for option in $(cat /etc/scratchpkg.conf.d/$PURGE_FILE); do
			if [ -e $option ]; then
				msg2 "Purging $option..."
				rm -fr $option
			fi
		done
	fi
}

strip_files() {
	
	msg2 "Stripping binaries..."	
		find . | xargs file | grep "executable" | grep ELF | cut -f 1 -d : | xargs strip --strip-unneeded 2> /dev/null
	msg2 "Stripping libraries..."	
		find . | xargs file | grep "shared object" | grep ELF | cut -f 1 -d : | xargs strip --strip-unneeded 2> /dev/null
}

compressinfomanpages() {
	
	if [ -d usr/share/man ]; then
		msg2 "Compressing man pages..."
		( cd usr/share/man
			find . -type f ! -name "*.gz" -exec gzip -9 {} \;
			for i in $(find . -type l) ; do ln -s $(readlink $i).gz $i.gz ; rm $i ; done
		) 
	fi
	
	if [ -d usr/share/info ]; then
		msg2 "Compressing info pages..."
		( cd usr/share/info
			find . -name "*.info*" -exec gzip -9 {} \;
		)
	fi
}

buildpkg() {
	
	getsource
	
	if [ -f .md5sum ]; then
		checkmdsum
	else
		updatemdsum
	fi
	
	preparesource
	
	if [ ! "$NO_PREINSTALL" ]; then
		runpreinstall
	fi
	
	buildpackage
	
	if [ "$FORCE_REBUILD" ]; then
		if [ -f $PACKAGE_DIR/$PKGNAME ]; then
			rm $PACKAGE_DIR/$PKGNAME
		fi
	fi
	
	packaging
	clearworkdir
		
}

checkdeps() {
	
	for dep in ${depends[@]}; do
		if [ ! -d $INDEX_DIR/$dep ]; then
			msg "Missing dep: ${color_yellow}$dep${color_reset}"
			MISSING_DEP=yes
		fi
	done
	
	for makedep in ${makedepends[@]}; do
		if [ ! -d $INDEX_DIR/$makedep ]; then
			msg "Missing dep: ${color_yellow}$makedep${color_reset} (make)"
			MISSING_DEP=yes
		fi
	done
	
	[ "$MISSING_DEP" ] && exitscript1
	
}

check_directory() {
	
	for dir in $WORK_DIR $SOURCE_DIR $PACKAGE_DIR; do
		if [ ! -d $dir ]; then
			msg "Directory ${color_yellow}$dir${color_reset} not exist."
			DIR_ERROR=yes
		elif [ ! -w $dir ]; then
			msg "Directory ${color_yellow}$dir${color_reset} not writable."
			DIR_ERROR=yes
		elif [ ! -x $dir ] || [ ! -r $1 ]; then
			msg "Directory ${color_yellow}$dir${color_reset} not readable."
			DIR_ERROR=yes
		fi
	done
	
	[ "$DIR_ERROR" ] && exitscript1
}

# remove lock file and exit 1
exitscript1() {
	
	if [ -f /tmp/spkg.$name.lock ]; then
		rm /tmp/spkg.$name.lock
	fi
	exit 1
}

# remove lock file and exit 0
exitscript0() {
	
	if [ -f /tmp/spkg.$name.lock ]; then
		rm /tmp/spkg.$name.lock
	fi
	exit 0
}

# create lock file in /tmp prevent for build same package simultaneously 
lockbuild() {
	
	if [ ! -f /tmp/spkg.$name.lock ]; then
		touch /tmp/spkg.$name.lock
	fi
}

clearworkdir() {
	
	if [ ! "$KEEP_WORK" ]; then
		if [ ! -z $name ]; then
			if [ -d $WORK_DIR/$name ]; then
				rm -fr $WORK_DIR/$name
			fi
		fi
	fi
	
}

interrupted() {
	echo ""
	msg "${color_yellow}Interrupted!${color_reset}"
	clearworkdir
	exitscript1
}

parse_options() {
	
	while [ "$1" ]; do
		case $1 in
		-id|--ignore-dependency)
			IGNORE_DEP=yes
			;;
		-fr|--force-rebuild)
			FORCE_REBUILD=yes
			;;
		-do|--download-only)
			DOWNLOAD_ONLY=yes
			;;
		-eo|--extract-only)
			EXTRACT_ONLY=yes
			;;
		-i|--install)
			INSTALL_PKG=yes
			;;
		-u|--upgrade)
			UPGRADE_PKG=yes
			;;
		-kw|--keep-work)
			KEEP_WORK=yes
			;;
		-ns|--no-strip)
			NO_STRIP=yes
			;;
		--no-preinstall)
			NO_PREINSTALL=yes
			;;
		-rd|--redownload)
			REDOWNLOAD_SOURCE=yes
			;;
		-uc|--update-checksum)
			UPDATE_CHECKSUM=yes
			;;
		-cc|--check-checksum)
			CHECK_CHECKSUM=yes
			;;
		-sd|--source-dir)
			if [ ! "$2" ]; then
				msg "Option '$1' require an argument (source path for package)."
				exit 1
			fi
			SOURCE_PKG="$2"
			shift
			;;
		-o|--output)
			if [ ! "$2" ]; then
				msg "Option '$1' require an argument (output path for compiled package)."
				exit 1
			fi
			OUTPUT_PKG="$2"
			shift
			;;
		*)
			msg "Option invalid!"
			exit 1
			;;
		esac
		shift
	done
	
}

main() {
	
	. /usr/share/scratchpkg/functions || exit 1
	
	### LOAD CONFIGURATION FILE ###
	if [ -f $CONF_FILE ]; then
		. $CONF_FILE
	else
		msg "${color_red}Configuration file not found.${color_reset}"
		exit 1
	fi
	
	parse_options "$@"
	
	### SET OUTPUT PATH FOR PACKAGE ###
	if [ $OUTPUT_PKG ]; then
		PACKAGE_DIR="$OUTPUT_PKG"
	fi
	
	### SET SOURCE PATH ###
	if [ $SOURCE_PKG ]; then
		SOURCE_DIR="$SOURCE_PKG"
	fi
	
	check_directory
	
	loadspkgbuild
	
	### CHECK SPKGBUILD ###
	if [ -z $name ] || [ -z $version ] || [ -z $release ]; then
		msg "Error, please check spkgbuild"
		exit 1
	fi
	
	PKGNAME="$name#$version-$release.spkg.txz"
	
	### SET NO STRIP ###
	#if [ $NO_STRIP ]; then
	#	STRIP_PACKAGE="no"
	#fi
	
	### UPDATE CHECKSUM ###
	if [ "$UPDATE_CHECKSUM" ]; then
		getsource
		updatemdsum
		exit 0
	fi
	
	### CHECK CHECKSUM ###
	if [ "$CHECK_CHECKSUM" ]; then
		checkmdsum
		exit 0
	fi
	
	### CHECK FOR LOCK FILE ###
	if [ -f /tmp/spkg.$name.lock ]; then
		msg "Cant build same package simultaneously."
		msg "remove ${color_yellow}/tmp/spkg.$name.lock${color_reset} if no build process for ${color_yellow}$name.${color_reset}"
		exit 1
	fi
	
	### DOWNLOAD ONLY ###
	if [ "$DOWNLOAD_ONLY" ]; then
		getsource
		exit 0
	fi
	
	### EXTRACT ONLY ###
	if [ "$EXTRACT_ONLY" ]; then
		preparesource
		exit 0
	fi
	
	### CREATE LOCK FILE ###
	lockbuild
	
	### BUILD ###
	if [ -f $PACKAGE_DIR/$PKGNAME ] && [ ! "$FORCE_REBUILD" ]; then
		if [ ! "$UPGRADE_PKG" ]; then
			msg "${color_green}$PKGNAME${color_reset} is up-to-date."
			if [ ! "$INSTALL_PKG" ]; then
				exitscript0
			fi
		fi
	else
		# dependency check
		if [ ! "$IGNORE_DEP" ]; then
			checkdeps
		fi
		buildpkg
	fi
	
	### INSTALL PACKAGE ###
	if [ "$INSTALL_PKG" ]; then
		NO_PREINSTALL=yes
		if [ "$IGNORE_DEP" ]; then
			installpkg $PACKAGE_DIR/$PKGNAME -id
			exitscript0
		else
			installpkg $PACKAGE_DIR/$PKGNAME
			exitscript0
		fi
	fi
	
	### UPGRADE PACKAGE ###
	if [ "$UPGRADE_PKG" ]; then
		installpkg $PACKAGE_DIR/$PKGNAME -u
		exitscript0
	fi
	
	exitscript0
	
}

trap "interrupted" SIGHUP SIGINT SIGQUIT SIGTERM

main "$@"
